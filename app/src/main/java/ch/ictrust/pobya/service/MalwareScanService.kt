/*
 * This file is part of PObY-A.
 *
 * Copyright (C) 2023 ICTrust SÃ rl
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
package ch.ictrust.pobya.service

import android.app.Application
import android.app.Service
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.IBinder
import android.util.Log
import android.widget.Toast
import androidx.lifecycle.MutableLiveData
import ch.ictrust.pobya.R
import ch.ictrust.pobya.cvd.ClamManager
import ch.ictrust.pobya.cvd.ScanType
import ch.ictrust.pobya.cvd.models.CVDType
import ch.ictrust.pobya.cvd.repositroy.CVDVersionRepository
import ch.ictrust.pobya.models.ApplicationState
import ch.ictrust.pobya.models.InstalledApplication
import ch.ictrust.pobya.models.MalwareScan
import ch.ictrust.pobya.models.MalwareScanDetails
import ch.ictrust.pobya.repository.ApplicationRepository
import ch.ictrust.pobya.repository.MalwareCertRepository
import ch.ictrust.pobya.repository.MalwareRepository
import ch.ictrust.pobya.repository.MalwareScanDetailsRepository
import ch.ictrust.pobya.repository.MalwareScanRepository
import ch.ictrust.pobya.utillies.ApplicationPermissionHelper
import ch.ictrust.pobya.utillies.HashUtils
import ch.ictrust.pobya.utillies.Prefs
import ch.ictrust.pobya.utillies.Utilities
import ch.ictrust.pobya.utillies.Utilities.toHex
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.security.MessageDigest
import java.util.Date


class MalwareScanService : Service() {

    private var malwarePackageListString: ArrayList<String> = ArrayList()
    private var TAG: String = "MalwareScanService"
    private var progress: Float = 0F
    private var malwarePackagesApps: ArrayList<InstalledApplication> = ArrayList()
    private val mDigestSHA256 = MessageDigest.getInstance("sha256")


    companion object {
        var scanProgressLiveData = MutableLiveData<Float>()
        var scanStatus = MutableLiveData<String>()
        var detectedMalwarePackagesApps = MutableLiveData<ArrayList<InstalledApplication>>()
    }

    override fun onCreate() {
        super.onCreate()
        progress = 0F
    }

    override fun onBind(intent: Intent?): IBinder? {
        TODO("Not yet implemented")
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {

        val deepScanEnabled = Prefs.getInstance(applicationContext)?.deepScanEnabled

        val extractDir = applicationContext?.getExternalFilesDir(null)?.path +
                File.separator.toString() + ClamManager.EXTRACT_FOLDER_NAME
        // Cleanup the extract directory
        File(extractDir).deleteRecursively()


        var typeScan = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            intent?.getParcelableExtra("type", ScanType::class.java)
        } else {
            @Suppress("DEPRECATION")
            intent?.getParcelableExtra<ScanType>("type")
        }

        if (typeScan == null) {
            typeScan = if (deepScanEnabled == true)
                ScanType.HSB_NDB else ScanType.HSB
        }

        malwarePackagesApps = ArrayList()
        progress = 0F
        val scanSysApps = Prefs.getInstance(applicationContext)?.enableSysAppScan
        var installedApplications: List<InstalledApplication>


        Utilities.dbScope.launch {
            val lastUpdate =
                CVDVersionRepository.getInstance(application).getLast(CVDType.DAILY)

            if (lastUpdate == null || (Date().time - lastUpdate.updateDate) < 86400000) {
                // TODO: remove hardcoded strings
                scanStatus.postValue(applicationContext.getString(R.string.updating))
                if (Utilities.updateMalwareDB(applicationContext)) {
                    scanStatus.postValue(applicationContext.getString(R.string.success))
                } else {
                    scanStatus.postValue(applicationContext.getString(R.string.failed))
                    // Toast show message
                    withContext(Dispatchers.Main) {
                        Toast.makeText(
                            baseContext,
                            getString(R.string.update_database_failed),
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                }
            }

            val currentScanTime = System.currentTimeMillis()
            val currentMalwareDbVersion = Prefs.getInstance(applicationContext)?.pobyDbVersion

            var currentCVDVersionDaily = 0
            var currentCVDVersionMain = 0
            try {
                currentCVDVersionDaily = CVDVersionRepository.getInstance(application)
                    .getLast(CVDType.DAILY).version.toInt()
                currentCVDVersionMain = CVDVersionRepository.getInstance(application)
                    .getLast(CVDType.MAIN).version.toInt()
            } catch (e: Exception) {
                Log.e(TAG, e.message.toString())
            }

            // Insert new scan: set number of treats to 0
            val currentScan = MalwareScanRepository.getInstance(application).insert(
                MalwareScan(
                    currentScanTime,
                    malwarePackagesApps.size,
                    currentMalwareDbVersion!!,
                    currentCVDVersionDaily,
                    currentCVDVersionMain
                )
            )

            scanStatus.postValue(applicationContext.getString(R.string.scanning))
            installedApplications =
                ApplicationPermissionHelper(baseContext, scanSysApps!!).getListApps(true)
            malwarePackageListString =
                MalwareRepository.getInstance(applicationContext as Application)
                    .getAllMalware() as ArrayList<String>
            malwarePackagesApps = ArrayList()
            val increment = 100.00 / installedApplications.size

            // Check if the mal-DB is empty
            if (malwarePackageListString.size == 0 && scanStatus.value != applicationContext.getString(
                    R.string.updating
                )
            ) {
                // wait for stats to be to 0 before showing the toast
                withContext(Dispatchers.Main) {
                    Toast.makeText(baseContext, getString(R.string.empty_db), Toast.LENGTH_SHORT)
                        .show()
                }
                scanStatus.postValue(applicationContext.getString(R.string.empty_db))
                return@launch
            }

            for (app in installedApplications) {
                val pm = applicationContext.packageManager.getPackageInfo(
                    app.packageName, PackageManager.GET_SIGNATURES
                )

                val currentApp = ApplicationRepository.getInstance(application)
                    .getAppByPackageName(app.packageName)

                val appHash = HashUtils.getCheckSumFromFilePath(
                    mDigestSHA256,
                    pm.applicationInfo!!.publicSourceDir
                )


                if (app.packageName == applicationContext.packageName) {
                    progress += increment.toFloat()
                    scanProgressLiveData.postValue(progress)
                    continue
                }

                // TO-DO: get the version of the database used to scan the current app from Malware
                //      Scan details if the database version used for the scan is different from the
                //      current database version then rescan the app

                // If lastHash is the same as the current hash, skip the app
                if (app.lastHash == appHash || app.trusted) {

                    Log.d(TAG, "Skipping app: ${app.packageName} - ${appHash} - ${app.lastHash}")

                    if (app.applicationState == ApplicationState.MALWARE || app.applicationState == ApplicationState.SUSPICIOUS) {
                        // Update current scan threats
                        malwarePackagesApps.add(app)
                        currentScan.nbrThreats = malwarePackagesApps.size
                        MalwareScanRepository.getInstance(application).update(currentScan)

                        // Add to detected malware list and update
                        detectedMalwarePackagesApps.postValue(malwarePackagesApps)
                    }
                    progress += increment.toFloat()
                    scanProgressLiveData.postValue(progress)
                    continue
                }

                // Perform the scan
                val detectedSig = ClamManager.getInstance(applicationContext)
                    .clamScan(pm.applicationInfo!!.publicSourceDir, typeScan)

                // Add information to AppScanResult with information
                if (detectedSig != null) {
                    val details = MalwareScanDetails(
                        currentScan.id,
                        detectedSig.signature,
                        detectedSig.malwareName,
                        app.packageName
                    )

                    // Set current InstalledApplication as threat
                    currentApp.flaggedAsThreat = true
                    currentApp.flagReason = detectedSig.malwareName
                    currentApp.applicationState = ApplicationState.MALWARE
                    currentApp.lastHash = HashUtils.getCheckSumFromFilePath(
                        mDigestSHA256,
                        pm.applicationInfo!!.publicSourceDir
                    )

                    // Update current scan threats
                    malwarePackagesApps.add(currentApp)
                    currentScan.nbrThreats = malwarePackagesApps.size
                    MalwareScanRepository.getInstance(application).update(currentScan)

                    // Add to detected malware list and update
                    detectedMalwarePackagesApps.postValue(malwarePackagesApps)
                    ApplicationRepository.getInstance(application).update(currentApp)

                    // Insert details to database
                    MalwareScanDetailsRepository.getInstance(application).insert(details)
                    progress += increment.toFloat()
                    // update progress and continue
                    scanProgressLiveData.postValue(progress)
                    continue
                }

                // Check if certificate exist in mal-db
                val hexSignature = ApplicationPermissionHelper(baseContext, scanSysApps)
                    .getAppCert(app.packageName)
                    .toHex()

                if (malwarePackageListString.contains(app.packageName)) {
                    if (MalwareCertRepository.getInstance(applicationContext as Application)
                            .getAllMalwareCerts().contains(hexSignature)
                    ) {


                        currentApp.flaggedAsThreat = true
                        currentApp.flagReason = "PObY.PackageName"
                        currentApp.applicationState = ApplicationState.SUSPICIOUS
                        currentApp.flaggedAsThreat = true
                        currentApp.lastHash = appHash

                        val details = MalwareScanDetails(
                            currentScan.id,
                            currentApp.flagReason!!,
                            currentApp.flagReason!!,
                            app.packageName
                        )

                        // Update current scan threats
                        malwarePackagesApps.add(currentApp)
                        currentScan.nbrThreats = malwarePackagesApps.size
                        MalwareScanRepository.getInstance(application).update(currentScan)

                        // Add to detected malware list and update
                        detectedMalwarePackagesApps.postValue(malwarePackagesApps)
                        ApplicationRepository.getInstance(application).update(currentApp)

                        // Insert details to database
                        MalwareScanDetailsRepository.getInstance(application).insert(details)
                        progress += increment.toFloat()
                        // update progress and continue
                        scanProgressLiveData.postValue(progress)
                        continue
                    }
                }

                if (MalwareCertRepository.getInstance(applicationContext as Application)
                        .getAllMalwareCerts().contains(hexSignature)
                ) {
                    currentApp.flaggedAsThreat = true
                    currentApp.flagReason = "PObY.SuspiciousCertificate"
                    currentApp.applicationState = ApplicationState.SUSPICIOUS
                    currentApp.flaggedAsThreat = true
                    currentApp.lastHash = appHash

                    val details = MalwareScanDetails(
                        currentScan.id,
                        currentApp.flagReason!!,
                        currentApp.flagReason!!,
                        app.packageName
                    )

                    // Update current scan threats
                    malwarePackagesApps.add(currentApp)
                    currentScan.nbrThreats = malwarePackagesApps.size
                    MalwareScanRepository.getInstance(application).update(currentScan)

                    // Add to detected malware list and update
                    detectedMalwarePackagesApps.postValue(malwarePackagesApps)
                    ApplicationRepository.getInstance(application).update(currentApp)

                    // Insert details to database
                    MalwareScanDetailsRepository.getInstance(application).insert(details)
                    progress += increment.toFloat()

                    // update progress and continue
                    scanProgressLiveData.postValue(progress)
                    continue
                }

                currentApp.flaggedAsThreat = false
                currentApp.lastHash = appHash
                ApplicationRepository.getInstance(application).update(currentApp)
                // Update progress
                progress += increment.toFloat()
                scanProgressLiveData.postValue(progress)
            }

            scanStatus.postValue(applicationContext.getString(R.string.done))
        }
        stopSelf()
        return START_STICKY
    }


}